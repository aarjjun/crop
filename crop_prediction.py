# -*- coding: utf-8 -*-
"""CROP PREDICTION.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/180GCYLd8nbEDY49GG7qUNQ-T0iKOUCx4
"""


#CROP PREDICTION WITH SIMPLE NEURAL NETWORK
import numpy as np
import pandas as pd

from sklearn.model_selection import train_test_split


crop_name =pd.read_csv('Crop_recommendation.csv')
crop_name.head()

crop_name['label'].unique()

from sklearn.preprocessing import LabelEncoder
encoder = LabelEncoder()
crop_name['label'] = encoder.fit_transform(crop_name['label'])

crop_name['label'].unique()

crop_name.shape

crop_name.info()

crop_name.isnull().sum()

crop_name.describe()

x = crop_name.drop(columns='label',axis=1)
y = crop_name['label']

print(x)

print(y)

x_train,x_test,y_train,y_test = train_test_split(x,y,test_size=0.2,random_state=2)

print(x.shape,x_train.shape,x_test.shape)

from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()
x_train_std = scaler.fit_transform(x_train)
x_test_std = scaler.transform(x_test)

import tensorflow as tf
tf.random.set_seed(3)
from tensorflow import keras

num_classes = len(np.unique(y_train))
print("Number of unique classes:", num_classes)

# Adjust the number of neurons in your output layer to match the number of classes
model = keras.Sequential([
    keras.layers.Flatten(input_shape=(7,)),
    keras.layers.Dense(10,activation='relu'),
    keras.layers.Dense(num_classes, activation='softmax') # Use softmax for multi-class classification
])

# Recompile the model with the updated output layer
model.compile(optimizer='adam',loss='sparse_categorical_crossentropy',metrics=['accuracy'])

# Encode your labels
from sklearn.preprocessing import LabelEncoder
encoder = LabelEncoder()
y_train = encoder.fit_transform(y_train)

# Now fit the model
model.fit(x_train_std,y_train,epochs= 50)

model.compile(optimizer='adam',loss='sparse_categorical_crossentropy',metrics=['accuracy'])

from sklearn.preprocessing import LabelEncoder
encoder = LabelEncoder()
y_train = encoder.fit_transform(y_train)

crop_name['label'].unique()

from sklearn.preprocessing import LabelEncoder
encoder = LabelEncoder()
y_test = encoder.fit_transform(y_test)
loss,accuracy = model.evaluate(x_test_std,y_test)
print(accuracy)

y_pred = model.predict(x_test_std)

print(y_pred)

from google.colab import files

y_pred_df = pd.DataFrame(y_pred)

# Now you can save it to a CSV file
y_pred_df.to_csv('y_pred.csv', index=False)
files.download('y_pred.csv')

from operator import index
my_list =[3.276727e-10,4.231563e-09,0.0005655693,0.96571475,1.6933953e-08,9.802196e-08,5.0661124e-09,0.002141781,7.3240955e-11,0.016259504,0.003464912,1.20633595e-05,5.6018547e-05,0.011747077,1.997257e-08,4.64513e-06,1.8416847e-10,5.3294605e-07,3.2947937e-05,2.22035e-12,4.39531e-11,2.4826885e-08]
index_of_my_value = np.argmax(my_list)
print(my_list)
print(index_of_my_value)

y_pred_labels = [np.argmax(i) for i in y_pred]
print(y_pred_labels)

input_data =(21,39,20,27.06179658,52.3003173,7.38,60.74)

input_data_as_numpy_array = np.asarray(input_data)
input_data_reshaped = input_data_as_numpy_array.reshape(1,-1)
input_data_std = scaler.transform(input_data_reshaped)
prediction = model.predict(input_data_std)
print(prediction)
prediction_label = [np.argmax(prediction)]
print(prediction_label)
if prediction_label == [20]:
    print("rice")
elif prediction_label == [11]:
    print("maize")
elif prediction_label == [3]:
    print("chickpea")
elif prediction_label == [9]:
    print("kidneybeans")
elif prediction_label == [18]:
    print("pigeonpeas")
elif prediction_label == [13]:
    print("mothbeans")
elif prediction_label == [14]:
    print("mungbeans")
elif prediction_label == [2]:
    print("blackgram")
elif prediction_label == [10]:
    print("lentil")
elif prediction_label == [19]:
    print("pomogranate")
elif prediction_label == [1]:
    print("banana")
elif prediction_label == [12]:
    print("mango")
elif prediction_label == [7]:
    print("grapes")
elif prediction_label == [21]:
    print("watermelon")
elif prediction_label == [15]:
    print("muskmelon")
elif prediction_label == [0]:
    print("apple")
elif prediction_label == [16]:
    print("orange")
elif prediction_label == [17]:
    print("papaya")
elif prediction_label == [4]:
    print("coconut")
elif prediction_label == [6]:
    print("cotton")
elif prediction_label == [8]:
    print("jute")
else:
    print("coffee")



from flask import Flask, request, jsonify

from pyngrok import ngrok

app = Flask(__name__)
port = '5000'
key = '2jTqGi7n9v4SXKm8XFIBFHPWVac_3KQJj4UH8ibBQi5QUjQEa'
ngrok.set_auth_token(key)

# List active tunnels and terminate them
active_tunnels = ngrok.get_tunnels()
for tunnel in active_tunnels:
    print("Terminating tunnel:", tunnel.public_url)
    ngrok.disconnect(tunnel.public_url)

# Now establish a new tunnel
public_url = ngrok.connect(port).public_url
print('ngrok tunnel' + public_url + ' https://127.0.0.1:' + (port))


from flask_cors import CORS
app = Flask(__name__)
CORS(app)